# 📚 Week 4: Checkpoint & Mixed Practice

### **Objective**: Apply Weeks 1-3 concepts. Assess progress.

**Logic Focus**: Combine patterns (e.g., two-pointer, sorting).

**Goal**: Solve 12 problems (8 easy, 4 medium). Pass checkpoint.

**Platforms**: LeetCode, GFG, HackerRank.

- **Day 22 (Mon): Arrays & Two-Pointer**
    - **Theory (0.5 hr)**:
        - Review arrays, two-pointer.
        - **Video**: NeetCode's "Two-Pointer Recap" (15 min) ([YouTube](https://www.youtube.com/watch?v=0C6rM3Gk7Mc&t=600s)).
        - **Article**: GFG's "Array Recap" (15 min) ([Link](https://www.geeksforgeeks.org/array-data-structure/)).
    - **Practice (2.5 hr)**:
        - **Problem 1**: LeetCode: Rotate Array ([Link](https://leetcode.com/problems/rotate-array/)).
            - **Brute Force**: Shift one-by-one (O(n*k)).
            - **Better**: Extra array (O(n) space).
            - **Optimal**: Reverse parts (O(n), O(1) space).
            - **Pseudocode**:
                
                ```
                Input: array nums, k
                k = k % len(nums)
                Reverse nums[0..len-1]
                Reverse nums[0..k-1]
                Reverse nums[k..len-1]
                ```
                
            - **Logic Exercise**: Draw reverse process.
        - **Problem 2**: LeetCode: Container With Most Water ([Link](https://leetcode.com/problems/container-with-most-water/)).
            - **Brute Force**: Check all pairs (O(n²)).
            - **Better**: Two pointers (O(n)).
            - **Optimal**: Same, optimized movement (O(n)).
            - **Pseudocode**:
                
                ```
                Input: array height
                Initialize left = 0, right = len(height)-1, max_area = 0
                While left < right:
                    Area = min(height[left], height[right]) * (right-left)
                    Update max_area if area > max_area
                    If height[left] < height[right]: Increment left
                    Else: Decrement right
                Return max_area
                ```
                
            - **Logic Exercise**: Visualize pointer movement.
    - **Support**: Share code; I'll fix two-pointer logic.
- **Day 23 (Tue): Strings & Sliding Window**
    - **Theory (0.5 hr)**:
        - Review strings, sliding window.
        - **Video**: NeetCode's "Sliding Window Recap" (15 min) ([YouTube](https://www.youtube.com/watch?v=MK-NZ4hN7rs&t=300s)).
        - **Article**: GFG's "String Recap" (15 min) ([Link](https://www.geeksforgeeks.org/python-string/)).
    - **Practice (2.5 hr)**:
        - **Problem 1**: LeetCode: Longest Palindromic Substring ([Link](https://leetcode.com/problems/longest-palindromic-substring/)).
            - **Brute Force**: Check all substrings (O(n³)).
            - **Better**: Expand around center (O(n²)).
            - **Optimal**: Same, optimized checks (O(n²)).
            - **Pseudocode**:
                
                ```
                Input: string s
                Initialize max_len = 0, start = 0
                For i from 0 to len(s)-1:
                    Expand around (i, i) for odd length
                    Expand around (i, i+1) for even length
                    Update max_len, start if longer palindrome found
                Return s[start:start+max_len]
                ```
                
            - **Logic Exercise**: Draw expansion process.
        - **Problem 2**: GFG: First Non-Repeating Character ([Link](https://www.geeksforgeeks.org/given-a-string-find-its-first-non-repeating-character/)).
            - **Brute Force**: Check each char against others (O(n²)).
            - **Better**: Hashmap for counts (O(n)).
            - **Optimal**: Same, single pass (O(n)).
            - **Pseudocode**:
                
                ```
                Input: string s
                Initialize count hashmap
                For char in s: Increment count[char]
                For char in s: If count[char] == 1: Return char
                Return None
                ```
                
            - **Logic Exercise**: Explain hashmap logic.
    - **Support**: Share code; I'll clarify sliding window.
- **Day 24 (Wed): Searching**
    - **Theory (0.5 hr)**:
        - Review linear/binary search.
        - **Video**: Tushar Roy's "Binary Search Recap" (15 min) ([YouTube](https://www.youtube.com/watch?v=pYT9F8_LFTM&t=600s)).
        - **Article**: GFG's "Binary Search Recap" (15 min) ([Link](https://www.geeksforgeeks.org/binary-search/)).
    - **Practice (2.5 hr)**:
        - **Problem 1**: LeetCode: Search in Rotated Sorted Array ([Link](https://leetcode.com/problems/search-in-rotated-sorted-array/)).
            - **Brute Force**: Linear search (O(n)).
            - **Better**: Modified binary search (O(log n)).
            - **Optimal**: Same, handle rotations (O(log n)).
            - **Pseudocode**:
                
                ```
                Input: array nums, target
                Initialize left = 0, right = len(nums)-1
                While left <= right:
                    Mid = (left + right) // 2
                    If nums[mid] == target: Return mid
                    If nums[left] <= nums[mid]:
                        If nums[left] <= target < nums[mid]: right = mid - 1
                        Else: left = mid + 1
                    Else:
                        If nums[mid] < target <= nums[right]: left = mid + 1
                        Else: right = mid - 1
                Return -1
                ```
                
            - **Logic Exercise**: Draw rotation scenarios.
        - **Problem 2**: LeetCode: Find Minimum in Rotated Sorted Array ([Link](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)).
            - **Brute Force**: Linear scan (O(n)).
            - **Better**: Binary search (O(log n)).
            - **Optimal**: Same, clean logic (O(log n)).
            - **Pseudocode**:
                
                ```
                Input: array nums
                Initialize left = 0, right = len(nums)-1
                While left < right:
                    Mid = (left + right) // 2
                    If nums[mid] > nums[right]: left = mid + 1
                    Else: right = mid
                Return nums[left]
                ```
                
            - **Logic Exercise**: Explain minimum logic.
    - **Support**: Share code; I'll fix binary search errors.
- **Day 25 (Thu): Sorting**
    - **Theory (0.5 hr)**:
        - Review bubble, selection, insertion sort.
        - **Video**: NeetCode's "Sorting Recap" (15 min) ([YouTube](https://www.youtube.com/watch?v=JU767SDMDvA&t=300s)).
        - **Article**: GFG's "Sorting Algorithms" (15 min) ([Link](https://www.geeksforgeeks.org/sorting-algorithms/)).
    - **Practice (2.5 hr)**:
        - **Problem 1**: LeetCode: Merge Intervals ([Link](https://leetcode.com/problems/merge-intervals/)).
            - **Brute Force**: Check all pairs (O(n²)).
            - **Better**: Sort and merge (O(n log n)).
            - **Optimal**: Same, clean merging (O(n log n)).
            - **Pseudocode**:
                
                ```
                Input: intervals
                Sort intervals by start time
                Initialize result with first interval
                For each interval:
                    If overlaps with last result: Merge
                    Else: Add to result
                Return result
                ```
                
            - **Logic Exercise**: Draw interval merging.
        - **Problem 2**: GFG: Sort Array by Parity ([Link](https://www.geeksforgeeks.org/segregate-even-and-odd-numbers/)).
            - **Brute Force**: New arrays for even/odd (O(n) space).
            - **Better**: Two pointers in-place (O(1) space).
            - **Optimal**: Same, clean swaps (O(n)).
            - **Pseudocode**:
                
                ```
                Input: array nums
                Initialize left = 0, right = len(nums)-1
                While left < right:
                    If nums[left] odd and nums[right] even: Swap
                    If nums[left] even: Increment left
                    If nums[right] odd: Decrement right
                Return nums
                ```
                
            - **Logic Exercise**: Visualize swaps.
    - **Support**: Share code; I'll check sorting logic.
- **Day 26 (Fri): Mixed Practice**
    - **Theory (0.5 hr)**:
        - Review arrays, strings, searching, sorting.
        - **Video**: NeetCode's "Mixed Recap" (15 min) ([YouTube](https://www.youtube.com/watch?v=gD7A1VvSSB8&t=600s)).
        - **Article**: GFG's "DSA Basics" (15 min) ([Link](https://www.geeksforgeeks.org/learn-data-structures-and-algorithms-dsa-tutorial/)).
    - **Practice (2.5 hr)**:
        - **Problem 1**: LeetCode: Maximum Subarray ([Link](https://leetcode.com/problems/maximum-subarray/)).
            - **Brute Force**: Check all subarrays (O(n²)).
            - **Better**: Kadane's algorithm (O(n)).
            - **Optimal**: Same, handle negatives (O(n)).
            - **Pseudocode**:
                
                ```
                Input: array nums
                Initialize max_sum = nums[0], curr_sum = nums[0]
                For i from 1 to len(nums)-1:
                    curr_sum = max(nums[i], curr_sum + nums[i])
                    max_sum = max(max_sum, curr_sum)
                Return max_sum
                ```
                
            - **Logic Exercise**: Explain Kadane's logic.
        - **Problem 2**: LeetCode: Kth Largest Element in an Array ([Link](https://leetcode.com/problems/kth-largest-element-in-an-array/)).
            - **Brute Force**: Sort array (O(n log n)).
            - **Better**: Min-heap (O(n log k)).
            - **Optimal**: Quickselect (O(n) average).
            - **Pseudocode**:
                
                ```
                Input: array nums, k
                Sort nums in descending order
                Return nums[k-1]
                ```
                
            - **Logic Exercise**: Compare sorting vs heap.
    - **Support**: Share code; I'll prepare you for checkpoint.
- **Day 27 (Sat): Checkpoint**
    - **Theory (0.5 hr)**:
        - Review Weeks 1-3 for checkpoint prep.
        - **Video**: NeetCode's "Checkpoint Prep" (15 min) ([YouTube](https://www.youtube.com/watch?v=0C6rM3Gk7Mc&t=900s)).
        - **Article**: GFG's "Checkpoint Tips" (15 min) ([Link](https://www.geeksforgeeks.org/top-50-array-coding-problems-for-interviews/)).
    - **Practice (2.5 hr)**:
        - **Checkpoint**: Solve 5 problems in 2 hr on LeetCode:
            1. Two Sum ([Link](https://leetcode.com/problems/two-sum/)).
            2. Valid Palindrome ([Link](https://leetcode.com/problems/valid-palindrome/)).
            3. Search in Rotated Sorted Array ([Link](https://leetcode.com/problems/search-in-rotated-sorted-array/)).
            4. Merge Intervals ([Link](https://leetcode.com/problems/merge-intervals/)).
            5. Maximum Subarray ([Link](https://leetcode.com/problems/maximum-subarray/)).
            - **Goal**: 4/5 correct with optimal solutions. Write brute force, better, optimal for each.
            - **Logic Exercise**: Explain one solution aloud.
        - **Extra Problem**: GFG: Array Rotation ([Link](https://www.geeksforgeeks.org/array-rotation/)).
            - **Brute Force**: Shift one-by-one (O(n*k)).
            - **Better/Optimal**: Reverse parts (O(n)).
            - **Pseudocode**: Same as Rotate Array above.
    - **Support**: Share checkpoint solutions; I'll analyze and suggest focus areas.
- **Day 28 (Sun)**: Rest. Reflect on checkpoint results

---

# 📚 Day 22: Arrays & Two-Pointer Technique - Complete Guide

## 🎯 Learning Objectives
By the end of this session, you will:
- **Master** array manipulation techniques and in-place operations
- **Understand** the Two-Pointer pattern and its applications
- **Implement** optimal solutions for array rotation and water container problems
- **Recognize** when to apply two-pointer vs other approaches

---

## 📖 Arrays & Two-Pointer Fundamentals

### 🔍 **Array Manipulation Mastery**:
Arrays are the foundation of most algorithms. Today we focus on **in-place operations** and **space-optimal solutions**.

**Key Concepts:**
- **In-place algorithms**: Modify array without extra space
- **Cyclic operations**: Handle wraparound with modulo
- **Reversal techniques**: Powerful for rotation and palindromes
- **Two-pointer patterns**: Efficient for pair-finding and optimization

### 🎯 **Two-Pointer Technique Patterns**:

| Pattern | Description | Time | Use Cases |
|---------|-------------|------|-----------|
| **Opposite Ends** | Start from both ends, move inward | O(n) | Palindrome, container problems |
| **Same Direction** | Both pointers move in same direction | O(n) | Remove duplicates, sliding window |
| **Fast-Slow** | One pointer moves faster than other | O(n) | Cycle detection, finding middle |

---

## 🎬 Visual Understanding: Array Rotation

Understanding the **three-reversal technique**:

```
Original Array: [1, 2, 3, 4, 5, 6, 7]  k = 3
Goal: Rotate right by 3 → [5, 6, 7, 1, 2, 3, 4]

Step 1: Reverse entire array
[1, 2, 3, 4, 5, 6, 7] → [7, 6, 5, 4, 3, 2, 1]

Step 2: Reverse first k elements (k=3)
[7, 6, 5, 4, 3, 2, 1] → [5, 6, 7, 4, 3, 2, 1]
 ↑-----↑

Step 3: Reverse remaining elements
[5, 6, 7, 4, 3, 2, 1] → [5, 6, 7, 1, 2, 3, 4] ✅
          ↑---------↑

Magic! ✨ The array is rotated optimally in O(n) time, O(1) space!
```

---

## 📚 Learning Resources

### 🎥 Video Resources (Theory - 30 minutes):
1. **NeetCode's "Two-Pointer Recap"** (15 min) - [YouTube](https://www.youtube.com/watch?v=0C6rM3Gk7Mc&t=600s)
   - Essential patterns and problem-solving approach
2. **Abdul Bari's "Array ADT"** (10 min) - Fundamental array operations
3. **mycodeschool Two Pointers** (5 min) - Classic technique explanation

### 📄 Article Resources:
1. **GeeksforGeeks Array Recap** (15 min) - [Link](https://www.geeksforgeeks.org/array-data-structure/)
   - Comprehensive array operations reference
2. **Two Pointer Technique Guide** - Pattern recognition and applications
3. **In-Place Algorithm Design** - Space optimization strategies

---

## 🛠️ Problem 1: Rotate Array (LeetCode 189)

**Problem**: Rotate an array to the right by k steps.
**Link**: [LeetCode Rotate Array](https://leetcode.com/problems/rotate-array/)

### 🔨 Approach 1: Brute Force (Shift One-by-One)

**Algorithm Logic**:
- For each rotation, shift all elements one position right
- Repeat k times
- Simple but inefficient for large k

**Pseudocode**:
```
ALGORITHM RotateArrayBrute(nums, k):
    n = length of nums
    k = k % n  // Handle k > n
    
    FOR rotation = 1 to k:
        last = nums[n-1]
        FOR i = n-1 down to 1:
            nums[i] = nums[i-1]
        nums[0] = last
    
    RETURN nums
```

**Python Implementation**:
```python
def rotate_brute_force(nums, k):
    """
    Brute force rotation by shifting one position at a time
    Time: O(n*k), Space: O(1)
    """
    n = len(nums)
    if n <= 1:
        return nums
    
    k = k % n  # Handle k > n case
    
    for rotation in range(k):
        # Store last element
        last_element = nums[n - 1]
        
        # Shift all elements one position right
        for i in range(n - 1, 0, -1):
            nums[i] = nums[i - 1]
        
        # Place last element at beginning
        nums[0] = last_element
        
        print(f"After rotation {rotation + 1}: {nums}")
    
    return nums

# Test with step-by-step visualization
test_array = [1, 2, 3, 4, 5, 6, 7]
print("Original:", test_array)
result = rotate_brute_force(test_array.copy(), 3)
print("Final result:", result)
```

**Complexity Analysis**:
- **Time**: O(n*k) - k rotations, each taking O(n) time
- **Space**: O(1) - In-place modification
- **Problem**: Inefficient for large k values

### 🚀 Approach 2: Better (Extra Array)

**Algorithm Logic**:
- Create new array and place each element at its rotated position
- Copy back to original array
- More efficient but uses extra space

**Pseudocode**:
```
ALGORITHM RotateArrayExtra(nums, k):
    n = length of nums
    k = k % n
    
    result = new array of size n
    
    FOR i = 0 to n-1:
        new_position = (i + k) % n
        result[new_position] = nums[i]
    
    COPY result back to nums
    RETURN nums
```

**Python Implementation**:
```python
def rotate_extra_array(nums, k):
    """
    Use extra array to place elements at rotated positions
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    if n <= 1:
        return nums
    
    k = k % n
    result = [0] * n
    
    # Place each element at its rotated position
    for i in range(n):
        new_position = (i + k) % n
        result[new_position] = nums[i]
        print(f"nums[{i}] = {nums[i]} → position {new_position}")
    
    # Copy back to original array
    for i in range(n):
        nums[i] = result[i]
    
    return nums

# Test with detailed tracing
test_array = [1, 2, 3, 4, 5, 6, 7]
print("Original:", test_array)
print("Rotating by k=3:")
result = rotate_extra_array(test_array.copy(), 3)
print("Result:", result)
```

### 🎯 Approach 3: Optimal (Three-Reversal Technique)

**Algorithm Logic**:
- Reverse entire array
- Reverse first k elements
- Reverse remaining elements
- **Key Insight**: Reversal operations achieve rotation without extra space

**Pseudocode**:
```
ALGORITHM RotateArrayOptimal(nums, k):
    n = length of nums
    k = k % n
    
    REVERSE(nums, 0, n-1)      // Reverse entire array
    REVERSE(nums, 0, k-1)      // Reverse first k elements
    REVERSE(nums, k, n-1)      // Reverse remaining elements
    
    RETURN nums

FUNCTION REVERSE(nums, start, end):
    WHILE start < end:
        SWAP nums[start] and nums[end]
        INCREMENT start
        DECREMENT end
```

**Python Implementation**:
```python
def rotate_optimal(nums, k):
    """
    Optimal rotation using three-reversal technique
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    if n <= 1:
        return nums
    
    k = k % n  # Handle k > n
    if k == 0:
        return nums
    
    def reverse_array(arr, start, end):
        """Helper function to reverse array segment"""
        while start < end:
            arr[start], arr[end] = arr[end], arr[start]
            start += 1
            end -= 1
    
    print(f"Original array: {nums}")
    
    # Step 1: Reverse entire array
    reverse_array(nums, 0, n - 1)
    print(f"After reversing entire array: {nums}")
    
    # Step 2: Reverse first k elements
    reverse_array(nums, 0, k - 1)
    print(f"After reversing first {k} elements: {nums}")
    
    # Step 3: Reverse remaining elements
    reverse_array(nums, k, n - 1)
    print(f"After reversing remaining elements: {nums}")
    
    return nums

# Comprehensive test with multiple cases
test_cases = [
    ([1, 2, 3, 4, 5, 6, 7], 3, "Standard case"),
    ([1, 2], 1, "Small array"),
    ([1, 2, 3, 4, 5], 2, "Even rotation"),
    ([1, 2, 3, 4, 5, 6], 6, "Full rotation"),
    ([-1, -100, 3, 99], 2, "Negative numbers"),
]

print("=== Comprehensive Rotation Tests ===")
for nums, k, description in test_cases:
    print(f"\nTest: {description}")
    print(f"Input: {nums}, k={k}")
    result = rotate_optimal(nums.copy(), k)
    print(f"Output: {result}")
```

### 🔍 **Why the Three-Reversal Works**:

**Mathematical Proof**:
```
For array [a₁, a₂, ..., aₙ] rotated right by k:
Target: [aₙ₋ₖ₊₁, aₙ₋ₖ₊₂, ..., aₙ, a₁, a₂, ..., aₙ₋ₖ]

Step 1: Reverse entire → [aₙ, aₙ₋₁, ..., a₁]
Step 2: Reverse first k → [aₙ₋ₖ₊₁, aₙ₋ₖ₊₂, ..., aₙ, aₙ₋₁, ..., a₁]
Step 3: Reverse last n-k → [aₙ₋ₖ₊₁, aₙ₋ₖ₊₂, ..., aₙ, a₁, a₂, ..., aₙ₋ₖ] ✅
```

---

## 🛠️ Problem 2: Container With Most Water (LeetCode 11)

**Problem**: Find two lines that together with x-axis forms a container holding the most water.
**Link**: [LeetCode Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

### 🔨 Approach 1: Brute Force (Check All Pairs)

**Algorithm Logic**:
- Check every possible pair of lines
- Calculate area for each pair
- Track maximum area found

**Pseudocode**:
```
ALGORITHM MaxAreaBrute(height):
    max_area = 0
    n = length of height
    
    FOR i = 0 to n-2:
        FOR j = i+1 to n-1:
            width = j - i
            min_height = MIN(height[i], height[j])
            area = width * min_height
            max_area = MAX(max_area, area)
    
    RETURN max_area
```

**Python Implementation**:
```python
def max_area_brute_force(height):
    """
    Brute force: Check all possible pairs
    Time: O(n²), Space: O(1)
    """
    max_area = 0
    n = len(height)
    
    for i in range(n - 1):
        for j in range(i + 1, n):
            # Calculate area between lines i and j
            width = j - i
            min_height = min(height[i], height[j])
            area = width * min_height
            
            max_area = max(max_area, area)
            
            # Optional: Print for visualization
            if area > 0:
                print(f"Lines at {i}({height[i]}) and {j}({height[j]}): "
                      f"width={width}, height={min_height}, area={area}")
    
    return max_area

# Test with visualization
heights = [1, 8, 6, 2, 5, 4, 8, 3, 7]
print("Heights:", heights)
print("Visual representation:")
print("Index:", " ".join(f"{i:2}" for i in range(len(heights))))
print("Height:", " ".join(f"{h:2}" for h in heights))
result = max_area_brute_force(heights)
print(f"Maximum area: {result}")
```

### 🚀 Approach 2: Better (Two Pointers)

**Algorithm Logic**:
- Start with widest possible container (leftmost and rightmost lines)
- Move the pointer with smaller height inward
- **Key Insight**: Moving the taller line can never increase area

**Pseudocode**:
```
ALGORITHM MaxAreaTwoPointer(height):
    left = 0
    right = length(height) - 1
    max_area = 0
    
    WHILE left < right:
        width = right - left
        min_height = MIN(height[left], height[right])
        area = width * min_height
        max_area = MAX(max_area, area)
        
        IF height[left] < height[right]:
            INCREMENT left
        ELSE:
            DECREMENT right
    
    RETURN max_area
```

**Python Implementation**:
```python
def max_area_two_pointer(height):
    """
    Two pointer approach for optimal solution
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        # Calculate current area
        width = right - left
        min_height = min(height[left], height[right])
        area = width * min_height
        
        max_area = max(max_area, area)
        
        print(f"Left={left}(h={height[left]}), Right={right}(h={height[right]}), "
              f"Width={width}, MinHeight={min_height}, Area={area}")
        
        # Move pointer with smaller height
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_area

# Test with detailed step tracing
heights = [1, 8, 6, 2, 5, 4, 8, 3, 7]
print("Container With Most Water - Two Pointer Approach")
print("Heights:", heights)
result = max_area_two_pointer(heights)
print(f"Maximum area: {result}")
```

### 🎯 Approach 3: Optimal (Enhanced Two Pointers)

**Features**:
- Optimized pointer movement
- Early termination conditions
- Comprehensive edge case handling

**Python Implementation**:
```python
def max_area_optimal(height):
    """
    Optimal two-pointer with optimizations
    Time: O(n), Space: O(1)
    """
    if not height or len(height) < 2:
        return 0
    
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        # Calculate area
        width = right - left
        left_height, right_height = height[left], height[right]
        current_area = width * min(left_height, right_height)
        
        max_area = max(max_area, current_area)
        
        # Optimization: Skip lines of same or smaller height
        if left_height < right_height:
            # Move left pointer past all smaller or equal heights
            current_left_height = left_height
            while left < right and height[left] <= current_left_height:
                left += 1
        else:
            # Move right pointer past all smaller or equal heights
            current_right_height = right_height
            while left < right and height[right] <= current_right_height:
                right -= 1
    
    return max_area

# Comprehensive test suite
def test_container_solutions():
    """Test all approaches with various cases"""
    test_cases = [
        ([1, 8, 6, 2, 5, 4, 8, 3, 7], "Standard case"),
        ([1, 1], "Minimum case"),
        ([1, 2, 1], "Three elements"),
        ([2, 1], "Two elements"),
        ([1, 2, 4, 3], "Small case"),
        ([1, 8, 100, 2, 100, 4, 8, 3, 7], "High walls"),
    ]
    
    print("=== Container With Most Water - All Approaches ===")
    
    for heights, description in test_cases:
        print(f"\nTest: {description}")
        print(f"Heights: {heights}")
        
        brute_result = max_area_brute_force(heights.copy())
        two_pointer_result = max_area_two_pointer(heights.copy())
        optimal_result = max_area_optimal(heights.copy())
        
        print(f"Brute Force: {brute_result}")
        print(f"Two Pointer: {two_pointer_result}")
        print(f"Optimal: {optimal_result}")
        
        # Verify all approaches give same result
        if brute_result == two_pointer_result == optimal_result:
            print("✅ All approaches match")
        else:
            print("❌ Results don't match!")

# Run comprehensive tests
test_container_solutions()
```

### 🧠 **Why Two Pointers Works**:

**Intuitive Explanation**:
```
Key Insight: Area = width × min(height[left], height[right])

When height[left] < height[right]:
- Moving right pointer inward decreases width
- Min height stays same (still height[left])
- Therefore area can only decrease
- So we should move left pointer instead

This greedy choice is always optimal because:
1. We want maximum area
2. Keeping the shorter line while reducing width is suboptimal
3. Moving the shorter line gives chance for better area
```

---

## 🔄 Two-Pointer Pattern Recognition

### 📊 **Common Two-Pointer Patterns**:

| Problem Type | Pointer Movement | Key Insight |
|--------------|------------------|-------------|
| **Pair Sum** | Move based on sum comparison | Sorted array property |
| **Container/Area** | Move shorter element | Maximize limiting factor |
| **Palindrome** | Move inward from ends | Symmetric comparison |
| **Remove Duplicates** | Fast-slow same direction | Skip duplicates efficiently |
| **Sliding Window** | Expand/contract window | Maintain window properties |

### 🎯 **Pattern Selection Guide**:

```python
def identify_two_pointer_pattern(problem_description):
    """
    Guide for recognizing two-pointer opportunities
    """
    patterns = {
        "opposite_ends": [
            "palindrome check",
            "container problems", 
            "pair sum in sorted array",
            "reverse operations"
        ],
        "same_direction": [
            "remove duplicates",
            "move zeros",
            "partition arrays"
        ],
        "fast_slow": [
            "cycle detection",
            "find middle element",
            "remove nth from end"
        ]
    }
    
    # Pattern recognition logic
    if "sorted" in problem_description and "pair" in problem_description:
        return "opposite_ends"
    elif "remove" in problem_description or "partition" in problem_description:
        return "same_direction"
    elif "cycle" in problem_description or "middle" in problem_description:
        return "fast_slow"
    else:
        return "analyze_further"
```

---

## 🧠 Logic Exercises & Visualization

### Exercise 1: Manual Array Rotation
Practice the three-reversal technique:

```
Array: [10, 20, 30, 40, 50], k = 2
Expected: [40, 50, 10, 20, 30]

Step 1: Reverse entire array
[10, 20, 30, 40, 50] → [__, __, __, __, __]

Step 2: Reverse first k=2 elements  
[__, __, __, __, __] → [__, __, __, __, __]

Step 3: Reverse remaining elements
[__, __, __, __, __] → [__, __, __, __, __]

Your answer: ___________________
```

### Exercise 2: Container Area Calculation
Trace through two-pointer movement:

```
Heights: [2, 1, 3, 4, 2]
         0  1  2  3  4

Initial: left=0, right=4
Area = min(2, 2) × (4-0) = __
Move which pointer? __ Why? ________________

Next: left=__, right=__
Area = min(__, __) × (__-__) = __
Move which pointer? __ Why? ________________

Continue until left >= right...
Maximum area found: __
```

### Exercise 3: Pattern Recognition
Identify the best two-pointer approach:

```python
problems = [
    "Find if array has two numbers that sum to target",
    "Remove all zeros from array while maintaining order", 
    "Check if string is a palindrome",
    "Find maximum area under histogram",
    "Detect cycle in linked list"
]

# Your answers:
solutions = [
    # Problem 1: ___ (pattern type + brief explanation)
    # Problem 2: ___ (pattern type + brief explanation)
    # Problem 3: ___ (pattern type + brief explanation)
    # Problem 4: ___ (pattern type + brief explanation)
    # Problem 5: ___ (pattern type + brief explanation)
]
```

---

## 🎯 Practice Problems & Extensions

### Beginner Level:
1. **Reverse Array**: Implement in-place array reversal
2. **Two Sum**: Find pair that sums to target in sorted array
3. **Valid Palindrome**: Check if string reads same forwards/backwards

### Intermediate Level:
1. **3Sum**: Find triplets that sum to zero
2. **Trapping Rain Water**: Calculate trapped water between heights
3. **Sort Colors**: Partition array with three distinct values

### Advanced Level:
1. **4Sum**: Find quadruplets with given sum
2. **Longest Mountain**: Find longest mountain sequence in array
3. **Minimum Window Substring**: Find smallest substring containing all characters

### 🚀 **Implementation Challenges**:

```python
# Challenge 1: Generalized rotation
def rotate_left(nums, k):
    """Rotate array left by k positions using same technique"""
    # Your implementation here
    pass

# Challenge 2: Find rotation point
def find_rotation_point(nums):
    """Find where sorted array was rotated"""
    # Your implementation here
    pass

# Challenge 3: Container with vertical lines
def max_area_with_vertical_lines(heights, positions):
    """Container problem where lines aren't evenly spaced"""
    # Your implementation here
    pass
```

---

## 🚀 Performance Analysis & Optimization

### 📊 **Algorithm Comparison**:

| Problem | Brute Force | Two Pointer | Space | Notes |
|---------|-------------|-------------|-------|-------|
| **Rotate Array** | O(n×k) | O(n) | O(1) | Three reversals |
| **Container Water** | O(n²) | O(n) | O(1) | Greedy optimization |
| **Two Sum (sorted)** | O(n²) | O(n) | O(1) | Move based on sum |
| **Palindrome Check** | O(n) | O(n) | O(1) | Same complexity, cleaner |

### ⚡ **Optimization Techniques**:

1. **Early Termination**: Stop when optimal solution found
2. **Skip Duplicates**: Avoid redundant comparisons
3. **Boundary Checks**: Handle edge cases efficiently
4. **In-Place Operations**: Minimize space usage

### 🎯 **When to Use Two Pointers**:

✅ **Good Candidates**:
- Sorted arrays with pair/triplet problems
- String palindrome checks
- Container/area maximization problems
- In-place array modifications

❌ **Not Suitable**:
- Unsorted data without specific structure
- Problems requiring random access
- Complex state tracking needs
- Multi-dimensional optimization

---

## ✅ Key Takeaways

1. **Two-pointer technique** reduces O(n²) to O(n) for many problems
2. **Pattern recognition** is crucial for applying correct variant
3. **In-place operations** save space and often improve performance
4. **Three-reversal technique** is elegant solution for array rotation
5. **Greedy choices** in two-pointer often lead to optimal solutions
6. **Visualization** helps understand pointer movement logic
7. **Edge cases** are critical in array manipulation problems

---

# 🎯 Week 4: Checkpoint & Mixed Practice

### 📋 **Objective**: Apply Weeks 1-3 concepts and assess comprehensive progress

**Logic Focus**: Combine patterns (two-pointer, sorting, searching) for complex problem-solving mastery.

**Goal**: Master fundamental concepts through deliberate practice so you never forget them! 🚀

---

### 🔄 **Comprehensive Pattern Integration**

#### **Week 1-3 Concept Map**:
```
FUNDAMENTAL ALGORITHMS MASTERED
├── Week 1: Logic Building Foundations
│   ├── Variables & Data Types
│   ├── Conditional Logic (if-else, nested)
│   ├── Loop Patterns (for, while)
│   └── Problem Decomposition
├── Week 2: Advanced Logic Structures  
│   ├── Nested Loops & Complex Conditions
│   ├── Pattern Recognition
│   ├── Algorithm Optimization
│   └── Edge Case Handling
├── Week 3: Search & Sort Mastery
│   ├── Linear & Binary Search
│   ├── Bubble, Selection, Insertion Sort
│   ├── Complexity Analysis (Big O)
│   └── Algorithm Selection Strategy
└── Week 4: Integration & Application
    ├── Two-Pointer Techniques
    ├── Array Manipulation
    ├── Mixed Problem Solving
    └── Pattern Combination
```

### 🧩 **Mixed Practice Challenges**

#### **Challenge 1: Search + Sort Combination**
```python
def search_and_sort_challenge(nums, target):
    """
    Problem: Given an unsorted array, find if target exists.
    If found, sort the array and return target's new position.
    If not found, insert target, sort, and return position.
    
    Combine: Binary search + Insertion sort + Two-pointer
    """
    # Your implementation combining multiple patterns
    pass

# Test cases for comprehensive practice
test_cases = [
    ([3, 1, 4, 1, 5], 2),  # Insert and sort
    ([2, 7, 1, 3], 7),     # Find and reposition
    ([5, 2, 8, 1], 4),     # Complex insertion
]
```

#### **Challenge 2: Two-Pointer + Sorting Integration**
```python
def optimize_array_operations(nums):
    """
    Problem: Given array of integers:
    1. Remove duplicates using two-pointer
    2. Sort remaining elements
    3. Find pair that sums to maximum value
    
    Combine: Two-pointer + Sorting + Pair finding
    """
    # Step 1: Remove duplicates (two-pointer technique)
    # Step 2: Sort array (choose optimal sort)
    # Step 3: Find optimal pair (two-pointer on sorted array)
    pass
```

#### **Challenge 3: Multi-Pattern Problem Solving**
```python
def container_rotation_combo(heights, k):
    """
    Problem: 
    1. Rotate array of heights by k positions
    2. Find maximum water container area
    3. Sort heights and find median
    
    Combine: Array rotation + Two-pointer + Sorting
    """
    # Step 1: Rotate using three-reversal technique
    # Step 2: Find max area using two-pointer
    # Step 3: Sort and find median
    pass
```

### 📊 **Progress Assessment Matrix**

#### **Skill Mastery Checklist**:
```
FUNDAMENTAL SKILLS ASSESSMENT (Rate 1-5):

Basic Programming Concepts:
[ ] Variables and data types            [_/5]
[ ] Conditional statements (if-else)    [_/5]
[ ] Loop structures (for, while)        [_/5]
[ ] Function implementation             [_/5]

Search Algorithms:
[ ] Linear search implementation        [_/5]
[ ] Binary search mastery              [_/5]
[ ] Search optimization techniques      [_/5]
[ ] Edge case handling                 [_/5]

Sorting Algorithms:
[ ] Bubble sort understanding          [_/5]
[ ] Selection sort implementation      [_/5]
[ ] Insertion sort mastery             [_/5]
[ ] Algorithm selection skills         [_/5]

Advanced Techniques:
[ ] Two-pointer patterns               [_/5]
[ ] Array manipulation                 [_/5]
[ ] In-place operations               [_/5]
[ ] Complexity analysis               [_/5]

Problem Solving:
[ ] Pattern recognition               [_/5]
[ ] Multiple approach thinking        [_/5]
[ ] Code optimization                 [_/5]
[ ] Testing and debugging             [_/5]
```

### 🎯 **Retention-Focused Practice**

#### **Daily Reinforcement Exercises**:

**Monday - Search Mastery**:
```python
def daily_search_practice():
    """
    15-minute daily practice to never forget search algorithms
    """
    # Practice 1: Binary search variants
    # Practice 2: Search in rotated array
    # Practice 3: Find first/last occurrence
    pass
```

**Tuesday - Sort Reinforcement**:
```python
def daily_sort_practice():
    """
    15-minute daily practice to master sorting
    """
    # Practice 1: Choose optimal sort for scenario
    # Practice 2: Implement from memory
    # Practice 3: Optimize for specific constraints
    pass
```

**Wednesday - Two-Pointer Mastery**:
```python
def daily_pointer_practice():
    """
    15-minute daily practice for two-pointer patterns
    """
    # Practice 1: Opposite ends pattern
    # Practice 2: Same direction pattern
    # Practice 3: Fast-slow pattern
    pass
```

**Thursday - Mixed Patterns**:
```python
def daily_mixed_practice():
    """
    15-minute daily practice combining patterns
    """
    # Practice 1: Search + sort combination
    # Practice 2: Two-pointer + array manipulation
    # Practice 3: Complex problem decomposition
    pass
```

**Friday - Algorithm Selection**:
```python
def daily_selection_practice():
    """
    15-minute daily practice for choosing right algorithm
    """
    # Practice 1: Analyze problem constraints
    # Practice 2: Choose optimal approach
    # Practice 3: Justify complexity decisions
    pass
```

### 🏆 **Mastery Verification Tests**

#### **Test 1: Implementation from Memory**
```
Time Limit: 20 minutes
Task: Implement without references

1. Binary search algorithm
2. Insertion sort algorithm  
3. Two-pointer container problem
4. Array rotation using reversal

Success Criteria: All implementations work correctly
```

#### **Test 2: Problem Pattern Recognition**
```
Time Limit: 10 minutes
Task: Identify optimal approach for each problem

1. Find pair with given sum in sorted array
2. Sort array of 0s, 1s, and 2s
3. Find peak element in array
4. Rotate string to check if it's rotation of another
5. Remove duplicates from sorted array

Success Criteria: Correctly identify patterns and approaches
```

#### **Test 3: Code Optimization Challenge**
```
Time Limit: 15 minutes
Task: Optimize given inefficient code

Provided: Brute force solutions for 3 problems
Goal: Convert to optimal solutions using learned patterns

Success Criteria: Achieve optimal time/space complexity
```

### 🎨 **Creative Application Projects**

#### **Project 1: Smart Array Processor**
```python
class SmartArrayProcessor:
    """
    Create a class that can:
    1. Auto-detect if array needs sorting
    2. Choose optimal sorting algorithm
    3. Provide search capabilities
    4. Handle array transformations
    """
    def __init__(self, data):
        self.data = data
        self.is_sorted = self._check_sorted()
        
    def smart_search(self, target):
        """Choose linear or binary search based on array state"""
        pass
        
    def optimal_sort(self):
        """Choose best sorting algorithm for current data"""
        pass
        
    def transform(self, operation):
        """Apply two-pointer operations efficiently"""
        pass
```

#### **Project 2: Algorithm Learning Assistant**
```python
class AlgorithmTutor:
    """
    Interactive tool for practicing algorithms:
    1. Generate practice problems
    2. Provide step-by-step guidance
    3. Check solutions
    4. Track progress
    """
    def generate_practice_problem(self, algorithm_type):
        """Create random test cases for algorithm practice"""
        pass
        
    def check_solution(self, user_code, test_cases):
        """Verify correctness and analyze complexity"""
        pass
        
    def provide_hints(self, problem_type, current_approach):
        """Give guided hints without revealing solution"""
        pass
```

### 📈 **Long-term Retention Strategy**

#### **Spaced Repetition Schedule**:
```
Week 4:    Daily practice (15 min/day)
Week 5:    Every other day (15 min)
Week 6:    Twice per week (20 min each)
Week 8:    Weekly review (30 min)
Week 12:   Monthly comprehensive review (1 hour)

Goal: Move algorithms from short-term to long-term memory
```

#### **Progressive Difficulty Curve**:
```
Level 1: Implement basic algorithms from memory
Level 2: Solve variations and edge cases
Level 3: Combine multiple algorithms
Level 4: Optimize for specific constraints
Level 5: Teach and explain to others
```

### ✅ **Week 4 Completion Criteria**

**To successfully complete Week 4, you should:**

- [ ] **Demonstrate mastery** of all Week 1-3 algorithms from memory
- [ ] **Solve mixed problems** combining multiple patterns efficiently
- [ ] **Choose optimal approaches** for new problems without guidance
- [ ] **Explain algorithms** clearly to reinforce understanding
- [ ] **Complete retention exercises** to ensure long-term memory
- [ ] **Apply patterns** to solve novel, unseen problems
- [ ] **Optimize solutions** considering time/space constraints

### 🎓 **Graduation to Advanced Topics**

**Upon Week 4 completion, you'll be ready for:**
- Advanced data structures (stacks, queues, trees)
- Dynamic programming fundamentals
- Graph algorithms and traversals
- Advanced problem-solving patterns
- System design basics

**Remember**: The goal isn't just to solve problems once, but to internalize patterns so deeply that you can apply them instinctively! 🧠✨

---

## 🔗 Additional Resources

- [Two Pointer Technique Patterns](https://leetcode.com/discuss/study-guide/1688903/All-about-2-pointers)
- [Array Manipulation Algorithms](https://www.geeksforgeeks.org/array-data-structure/)
- [Visualization Tools](https://visualgo.net/en/sorting)
- [Practice Problems](https://leetcode.com/tag/two-pointers/)

