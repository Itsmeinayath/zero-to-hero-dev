# üìö Day 22: Arrays & Two-Pointer Technique - Complete Guide

## üéØ Learning Objectives
By the end of this session, you will:
- **Master** array manipulation techniques and in-place operations
- **Understand** the Two-Pointer pattern and its applications
- **Implement** optimal solutions for array rotation and water container problems
- **Recognize** when to apply two-pointer vs other approaches

---

## üìñ Arrays & Two-Pointer Fundamentals

### üîç **Array Manipulation Mastery**:
Arrays are the foundation of most algorithms. Today we focus on **in-place operations** and **space-optimal solutions**.

**Key Concepts:**
- **In-place algorithms**: Modify array without extra space
- **Cyclic operations**: Handle wraparound with modulo
- **Reversal techniques**: Powerful for rotation and palindromes
- **Two-pointer patterns**: Efficient for pair-finding and optimization

### üéØ **Two-Pointer Technique Patterns**:

| Pattern | Description | Time | Use Cases |
|---------|-------------|------|-----------|
| **Opposite Ends** | Start from both ends, move inward | O(n) | Palindrome, container problems |
| **Same Direction** | Both pointers move in same direction | O(n) | Remove duplicates, sliding window |
| **Fast-Slow** | One pointer moves faster than other | O(n) | Cycle detection, finding middle |

---

## üé¨ Visual Understanding: Array Rotation

Understanding the **three-reversal technique**:

```
Original Array: [1, 2, 3, 4, 5, 6, 7]  k = 3
Goal: Rotate right by 3 ‚Üí [5, 6, 7, 1, 2, 3, 4]

Step 1: Reverse entire array
[1, 2, 3, 4, 5, 6, 7] ‚Üí [7, 6, 5, 4, 3, 2, 1]

Step 2: Reverse first k elements (k=3)
[7, 6, 5, 4, 3, 2, 1] ‚Üí [5, 6, 7, 4, 3, 2, 1]
 ‚Üë-----‚Üë

Step 3: Reverse remaining elements
[5, 6, 7, 4, 3, 2, 1] ‚Üí [5, 6, 7, 1, 2, 3, 4] ‚úÖ
          ‚Üë---------‚Üë

Magic! ‚ú® The array is rotated optimally in O(n) time, O(1) space!
```

---

## üìö Learning Resources

### üé• Video Resources (Theory - 30 minutes):
1. **NeetCode's "Two-Pointer Recap"** (15 min) - [YouTube](https://www.youtube.com/watch?v=0C6rM3Gk7Mc&t=600s)
   - Essential patterns and problem-solving approach
2. **Abdul Bari's "Array ADT"** (10 min) - Fundamental array operations
3. **mycodeschool Two Pointers** (5 min) - Classic technique explanation

### üìÑ Article Resources:
1. **GeeksforGeeks Array Recap** (15 min) - [Link](https://www.geeksforgeeks.org/array-data-structure/)
   - Comprehensive array operations reference
2. **Two Pointer Technique Guide** - Pattern recognition and applications
3. **In-Place Algorithm Design** - Space optimization strategies

---

## üõ†Ô∏è Problem 1: Rotate Array (LeetCode 189)

**Problem**: Rotate an array to the right by k steps.
**Link**: [LeetCode Rotate Array](https://leetcode.com/problems/rotate-array/)

### üî® Approach 1: Brute Force (Shift One-by-One)

**Algorithm Logic**:
- For each rotation, shift all elements one position right
- Repeat k times
- Simple but inefficient for large k

**Pseudocode**:
```
ALGORITHM RotateArrayBrute(nums, k):
    n = length of nums
    k = k % n  // Handle k > n
    
    FOR rotation = 1 to k:
        last = nums[n-1]
        FOR i = n-1 down to 1:
            nums[i] = nums[i-1]
        nums[0] = last
    
    RETURN nums
```

**Python Implementation**:
```python
def rotate_brute_force(nums, k):
    """
    Brute force rotation by shifting one position at a time
    Time: O(n*k), Space: O(1)
    """
    n = len(nums)
    if n <= 1:
        return nums
    
    k = k % n  # Handle k > n case
    
    for rotation in range(k):
        # Store last element
        last_element = nums[n - 1]
        
        # Shift all elements one position right
        for i in range(n - 1, 0, -1):
            nums[i] = nums[i - 1]
        
        # Place last element at beginning
        nums[0] = last_element
        
        print(f"After rotation {rotation + 1}: {nums}")
    
    return nums

# Test with step-by-step visualization
test_array = [1, 2, 3, 4, 5, 6, 7]
print("Original:", test_array)
result = rotate_brute_force(test_array.copy(), 3)
print("Final result:", result)
```

**Complexity Analysis**:
- **Time**: O(n*k) - k rotations, each taking O(n) time
- **Space**: O(1) - In-place modification
- **Problem**: Inefficient for large k values

### üöÄ Approach 2: Better (Extra Array)

**Algorithm Logic**:
- Create new array and place each element at its rotated position
- Copy back to original array
- More efficient but uses extra space

**Pseudocode**:
```
ALGORITHM RotateArrayExtra(nums, k):
    n = length of nums
    k = k % n
    
    result = new array of size n
    
    FOR i = 0 to n-1:
        new_position = (i + k) % n
        result[new_position] = nums[i]
    
    COPY result back to nums
    RETURN nums
```

**Python Implementation**:
```python
def rotate_extra_array(nums, k):
    """
    Use extra array to place elements at rotated positions
    Time: O(n), Space: O(n)
    """
    n = len(nums)
    if n <= 1:
        return nums
    
    k = k % n
    result = [0] * n
    
    # Place each element at its rotated position
    for i in range(n):
        new_position = (i + k) % n
        result[new_position] = nums[i]
        print(f"nums[{i}] = {nums[i]} ‚Üí position {new_position}")
    
    # Copy back to original array
    for i in range(n):
        nums[i] = result[i]
    
    return nums

# Test with detailed tracing
test_array = [1, 2, 3, 4, 5, 6, 7]
print("Original:", test_array)
print("Rotating by k=3:")
result = rotate_extra_array(test_array.copy(), 3)
print("Result:", result)
```

### üéØ Approach 3: Optimal (Three-Reversal Technique)

**Algorithm Logic**:
- Reverse entire array
- Reverse first k elements
- Reverse remaining elements
- **Key Insight**: Reversal operations achieve rotation without extra space

**Pseudocode**:
```
ALGORITHM RotateArrayOptimal(nums, k):
    n = length of nums
    k = k % n
    
    REVERSE(nums, 0, n-1)      // Reverse entire array
    REVERSE(nums, 0, k-1)      // Reverse first k elements
    REVERSE(nums, k, n-1)      // Reverse remaining elements
    
    RETURN nums

FUNCTION REVERSE(nums, start, end):
    WHILE start < end:
        SWAP nums[start] and nums[end]
        INCREMENT start
        DECREMENT end
```

**Python Implementation**:
```python
def rotate_optimal(nums, k):
    """
    Optimal rotation using three-reversal technique
    Time: O(n), Space: O(1)
    """
    n = len(nums)
    if n <= 1:
        return nums
    
    k = k % n  # Handle k > n
    if k == 0:
        return nums
    
    def reverse_array(arr, start, end):
        """Helper function to reverse array segment"""
        while start < end:
            arr[start], arr[end] = arr[end], arr[start]
            start += 1
            end -= 1
    
    print(f"Original array: {nums}")
    
    # Step 1: Reverse entire array
    reverse_array(nums, 0, n - 1)
    print(f"After reversing entire array: {nums}")
    
    # Step 2: Reverse first k elements
    reverse_array(nums, 0, k - 1)
    print(f"After reversing first {k} elements: {nums}")
    
    # Step 3: Reverse remaining elements
    reverse_array(nums, k, n - 1)
    print(f"After reversing remaining elements: {nums}")
    
    return nums

# Comprehensive test with multiple cases
test_cases = [
    ([1, 2, 3, 4, 5, 6, 7], 3, "Standard case"),
    ([1, 2], 1, "Small array"),
    ([1, 2, 3, 4, 5], 2, "Even rotation"),
    ([1, 2, 3, 4, 5, 6], 6, "Full rotation"),
    ([-1, -100, 3, 99], 2, "Negative numbers"),
]

print("=== Comprehensive Rotation Tests ===")
for nums, k, description in test_cases:
    print(f"\nTest: {description}")
    print(f"Input: {nums}, k={k}")
    result = rotate_optimal(nums.copy(), k)
    print(f"Output: {result}")
```

### üîç **Why the Three-Reversal Works**:

**Mathematical Proof**:
```
For array [a‚ÇÅ, a‚ÇÇ, ..., a‚Çô] rotated right by k:
Target: [a‚Çô‚Çã‚Çñ‚Çä‚ÇÅ, a‚Çô‚Çã‚Çñ‚Çä‚ÇÇ, ..., a‚Çô, a‚ÇÅ, a‚ÇÇ, ..., a‚Çô‚Çã‚Çñ]

Step 1: Reverse entire ‚Üí [a‚Çô, a‚Çô‚Çã‚ÇÅ, ..., a‚ÇÅ]
Step 2: Reverse first k ‚Üí [a‚Çô‚Çã‚Çñ‚Çä‚ÇÅ, a‚Çô‚Çã‚Çñ‚Çä‚ÇÇ, ..., a‚Çô, a‚Çô‚Çã‚ÇÅ, ..., a‚ÇÅ]
Step 3: Reverse last n-k ‚Üí [a‚Çô‚Çã‚Çñ‚Çä‚ÇÅ, a‚Çô‚Çã‚Çñ‚Çä‚ÇÇ, ..., a‚Çô, a‚ÇÅ, a‚ÇÇ, ..., a‚Çô‚Çã‚Çñ] ‚úÖ
```

---

## üõ†Ô∏è Problem 2: Container With Most Water (LeetCode 11)

**Problem**: Find two lines that together with x-axis forms a container holding the most water.
**Link**: [LeetCode Container With Most Water](https://leetcode.com/problems/container-with-most-water/)

### üî® Approach 1: Brute Force (Check All Pairs)

**Algorithm Logic**:
- Check every possible pair of lines
- Calculate area for each pair
- Track maximum area found

**Pseudocode**:
```
ALGORITHM MaxAreaBrute(height):
    max_area = 0
    n = length of height
    
    FOR i = 0 to n-2:
        FOR j = i+1 to n-1:
            width = j - i
            min_height = MIN(height[i], height[j])
            area = width * min_height
            max_area = MAX(max_area, area)
    
    RETURN max_area
```

**Python Implementation**:
```python
def max_area_brute_force(height):
    """
    Brute force: Check all possible pairs
    Time: O(n¬≤), Space: O(1)
    """
    max_area = 0
    n = len(height)
    
    for i in range(n - 1):
        for j in range(i + 1, n):
            # Calculate area between lines i and j
            width = j - i
            min_height = min(height[i], height[j])
            area = width * min_height
            
            max_area = max(max_area, area)
            
            # Optional: Print for visualization
            if area > 0:
                print(f"Lines at {i}({height[i]}) and {j}({height[j]}): "
                      f"width={width}, height={min_height}, area={area}")
    
    return max_area

# Test with visualization
heights = [1, 8, 6, 2, 5, 4, 8, 3, 7]
print("Heights:", heights)
print("Visual representation:")
print("Index:", " ".join(f"{i:2}" for i in range(len(heights))))
print("Height:", " ".join(f"{h:2}" for h in heights))
result = max_area_brute_force(heights)
print(f"Maximum area: {result}")
```

### üöÄ Approach 2: Better (Two Pointers)

**Algorithm Logic**:
- Start with widest possible container (leftmost and rightmost lines)
- Move the pointer with smaller height inward
- **Key Insight**: Moving the taller line can never increase area

**Pseudocode**:
```
ALGORITHM MaxAreaTwoPointer(height):
    left = 0
    right = length(height) - 1
    max_area = 0
    
    WHILE left < right:
        width = right - left
        min_height = MIN(height[left], height[right])
        area = width * min_height
        max_area = MAX(max_area, area)
        
        IF height[left] < height[right]:
            INCREMENT left
        ELSE:
            DECREMENT right
    
    RETURN max_area
```

**Python Implementation**:
```python
def max_area_two_pointer(height):
    """
    Two pointer approach for optimal solution
    Time: O(n), Space: O(1)
    """
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        # Calculate current area
        width = right - left
        min_height = min(height[left], height[right])
        area = width * min_height
        
        max_area = max(max_area, area)
        
        print(f"Left={left}(h={height[left]}), Right={right}(h={height[right]}), "
              f"Width={width}, MinHeight={min_height}, Area={area}")
        
        # Move pointer with smaller height
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_area

# Test with detailed step tracing
heights = [1, 8, 6, 2, 5, 4, 8, 3, 7]
print("Container With Most Water - Two Pointer Approach")
print("Heights:", heights)
result = max_area_two_pointer(heights)
print(f"Maximum area: {result}")
```

### üéØ Approach 3: Optimal (Enhanced Two Pointers)

**Features**:
- Optimized pointer movement
- Early termination conditions
- Comprehensive edge case handling

**Python Implementation**:
```python
def max_area_optimal(height):
    """
    Optimal two-pointer with optimizations
    Time: O(n), Space: O(1)
    """
    if not height or len(height) < 2:
        return 0
    
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        # Calculate area
        width = right - left
        left_height, right_height = height[left], height[right]
        current_area = width * min(left_height, right_height)
        
        max_area = max(max_area, current_area)
        
        # Optimization: Skip lines of same or smaller height
        if left_height < right_height:
            # Move left pointer past all smaller or equal heights
            current_left_height = left_height
            while left < right and height[left] <= current_left_height:
                left += 1
        else:
            # Move right pointer past all smaller or equal heights
            current_right_height = right_height
            while left < right and height[right] <= current_right_height:
                right -= 1
    
    return max_area

# Comprehensive test suite
def test_container_solutions():
    """Test all approaches with various cases"""
    test_cases = [
        ([1, 8, 6, 2, 5, 4, 8, 3, 7], "Standard case"),
        ([1, 1], "Minimum case"),
        ([1, 2, 1], "Three elements"),
        ([2, 1], "Two elements"),
        ([1, 2, 4, 3], "Small case"),
        ([1, 8, 100, 2, 100, 4, 8, 3, 7], "High walls"),
    ]
    
    print("=== Container With Most Water - All Approaches ===")
    
    for heights, description in test_cases:
        print(f"\nTest: {description}")
        print(f"Heights: {heights}")
        
        brute_result = max_area_brute_force(heights.copy())
        two_pointer_result = max_area_two_pointer(heights.copy())
        optimal_result = max_area_optimal(heights.copy())
        
        print(f"Brute Force: {brute_result}")
        print(f"Two Pointer: {two_pointer_result}")
        print(f"Optimal: {optimal_result}")
        
        # Verify all approaches give same result
        if brute_result == two_pointer_result == optimal_result:
            print("‚úÖ All approaches match")
        else:
            print("‚ùå Results don't match!")

# Run comprehensive tests
test_container_solutions()
```

### üß† **Why Two Pointers Works**:

**Intuitive Explanation**:
```
Key Insight: Area = width √ó min(height[left], height[right])

When height[left] < height[right]:
- Moving right pointer inward decreases width
- Min height stays same (still height[left])
- Therefore area can only decrease
- So we should move left pointer instead

This greedy choice is always optimal because:
1. We want maximum area
2. Keeping the shorter line while reducing width is suboptimal
3. Moving the shorter line gives chance for better area
```

---

## üîÑ Two-Pointer Pattern Recognition

### üìä **Common Two-Pointer Patterns**:

| Problem Type | Pointer Movement | Key Insight |
|--------------|------------------|-------------|
| **Pair Sum** | Move based on sum comparison | Sorted array property |
| **Container/Area** | Move shorter element | Maximize limiting factor |
| **Palindrome** | Move inward from ends | Symmetric comparison |
| **Remove Duplicates** | Fast-slow same direction | Skip duplicates efficiently |
| **Sliding Window** | Expand/contract window | Maintain window properties |

### üéØ **Pattern Selection Guide**:

```python
def identify_two_pointer_pattern(problem_description):
    """
    Guide for recognizing two-pointer opportunities
    """
    patterns = {
        "opposite_ends": [
            "palindrome check",
            "container problems", 
            "pair sum in sorted array",
            "reverse operations"
        ],
        "same_direction": [
            "remove duplicates",
            "move zeros",
            "partition arrays"
        ],
        "fast_slow": [
            "cycle detection",
            "find middle element",
            "remove nth from end"
        ]
    }
    
    # Pattern recognition logic
    if "sorted" in problem_description and "pair" in problem_description:
        return "opposite_ends"
    elif "remove" in problem_description or "partition" in problem_description:
        return "same_direction"
    elif "cycle" in problem_description or "middle" in problem_description:
        return "fast_slow"
    else:
        return "analyze_further"
```

---

## üß† Logic Exercises & Visualization

### Exercise 1: Manual Array Rotation
Practice the three-reversal technique:

```
Array: [10, 20, 30, 40, 50], k = 2
Expected: [40, 50, 10, 20, 30]

Step 1: Reverse entire array
[10, 20, 30, 40, 50] ‚Üí [__, __, __, __, __]

Step 2: Reverse first k=2 elements  
[__, __, __, __, __] ‚Üí [__, __, __, __, __]

Step 3: Reverse remaining elements
[__, __, __, __, __] ‚Üí [__, __, __, __, __]

Your answer: ___________________
```

### Exercise 2: Container Area Calculation
Trace through two-pointer movement:

```
Heights: [2, 1, 3, 4, 2]
         0  1  2  3  4

Initial: left=0, right=4
Area = min(2, 2) √ó (4-0) = __
Move which pointer? __ Why? ________________

Next: left=__, right=__
Area = min(__, __) √ó (__-__) = __
Move which pointer? __ Why? ________________

Continue until left >= right...
Maximum area found: __
```

### Exercise 3: Pattern Recognition
Identify the best two-pointer approach:

```python
problems = [
    "Find if array has two numbers that sum to target",
    "Remove all zeros from array while maintaining order", 
    "Check if string is a palindrome",
    "Find maximum area under histogram",
    "Detect cycle in linked list"
]

# Your answers:
solutions = [
    # Problem 1: ___ (pattern type + brief explanation)
    # Problem 2: ___ (pattern type + brief explanation)
    # Problem 3: ___ (pattern type + brief explanation)
    # Problem 4: ___ (pattern type + brief explanation)
    # Problem 5: ___ (pattern type + brief explanation)
]
```

---

## üéØ Practice Problems & Extensions

### Beginner Level:
1. **Reverse Array**: Implement in-place array reversal
2. **Two Sum**: Find pair that sums to target in sorted array
3. **Valid Palindrome**: Check if string reads same forwards/backwards

### Intermediate Level:
1. **3Sum**: Find triplets that sum to zero
2. **Trapping Rain Water**: Calculate trapped water between heights
3. **Sort Colors**: Partition array with three distinct values

### Advanced Level:
1. **4Sum**: Find quadruplets with given sum
2. **Longest Mountain**: Find longest mountain sequence in array
3. **Minimum Window Substring**: Find smallest substring containing all characters

### üöÄ **Implementation Challenges**:

```python
# Challenge 1: Generalized rotation
def rotate_left(nums, k):
    """Rotate array left by k positions using same technique"""
    # Your implementation here
    pass

# Challenge 2: Find rotation point
def find_rotation_point(nums):
    """Find where sorted array was rotated"""
    # Your implementation here
    pass

# Challenge 3: Container with vertical lines
def max_area_with_vertical_lines(heights, positions):
    """Container problem where lines aren't evenly spaced"""
    # Your implementation here
    pass
```

---

## üöÄ Performance Analysis & Optimization

### üìä **Algorithm Comparison**:

| Problem | Brute Force | Two Pointer | Space | Notes |
|---------|-------------|-------------|-------|-------|
| **Rotate Array** | O(n√ók) | O(n) | O(1) | Three reversals |
| **Container Water** | O(n¬≤) | O(n) | O(1) | Greedy optimization |
| **Two Sum (sorted)** | O(n¬≤) | O(n) | O(1) | Move based on sum |
| **Palindrome Check** | O(n) | O(n) | O(1) | Same complexity, cleaner |

### ‚ö° **Optimization Techniques**:

1. **Early Termination**: Stop when optimal solution found
2. **Skip Duplicates**: Avoid redundant comparisons
3. **Boundary Checks**: Handle edge cases efficiently
4. **In-Place Operations**: Minimize space usage

### üéØ **When to Use Two Pointers**:

‚úÖ **Good Candidates**:
- Sorted arrays with pair/triplet problems
- String palindrome checks
- Container/area maximization problems
- In-place array modifications

‚ùå **Not Suitable**:
- Unsorted data without specific structure
- Problems requiring random access
- Complex state tracking needs
- Multi-dimensional optimization

---

## ‚úÖ Key Takeaways

1. **Two-pointer technique** reduces O(n¬≤) to O(n) for many problems
2. **Pattern recognition** is crucial for applying correct variant
3. **In-place operations** save space and often improve performance
4. **Three-reversal technique** is elegant solution for array rotation
5. **Greedy choices** in two-pointer often lead to optimal solutions
6. **Visualization** helps understand pointer movement logic
7. **Edge cases** are critical in array manipulation problems

---

## üîó Additional Resources

- [Two Pointer Technique Patterns](https://leetcode.com/discuss/study-guide/1688903/All-about-2-pointers)
- [Array Manipulation Algorithms](https://www.geeksforgeeks.org/array-data-structure/)
- [Visualization Tools](https://visualgo.net/en/sorting)
- [Practice Problems](https://leetcode.com/tag/two-pointers/)

